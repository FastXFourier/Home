# คำอธิบายวิธีทำพร้อม code สำหรับข้อ toi20_sculpture
## Link: https://otog.in.th/problem/1015

## สรุปโจทย์
มีหินอยู่ $N$ ก้อน แต่ละก้อนจะมีค่า $W[i]$ (น้ำหนักของหินก้อนที่ $i$) และ $L[i]$ (น้ำหนักสูงสุดที่หินก้อนที่ $i$ รับได้) โดยเราจะต้องสร้างผลงานประติมากรรม ตามเงื่อนไขดังต่อไปนี้:
- ต้องเลือกก้อนหินตามลำดับบนลงล่าง โดยบางก้อนเราเลือกที่จะไม่ใช้ก็ได้
- น้ำหนักรวมของหินด้านบน จะต้อง $\leq$ น้ำหนักสูงสุดที่หินด้านล่างรับได้
- มีอุปกรณ์พยุงน้ำหนักให้ใช้จำนวน 1 ชิ้น ซึ่งจะช่วยพยุงน้ำหนักของหินด้านบนทั้งหมด โดยนำไปใช้กับหินก้อนใดก็ได้ยกเว้นหินก้อนล่างสุด

## สิ่งที่ต้องทำ
หาจำนวนหินที่มากที่สุดที่สามารถนำมาใช้สร้างประติมากรรมที่ใช้อุปกรณ์พยุงน้าหนักก้อนหินตามเงื่อนไขที่กำหนด และระบุว่าสามารถใส่อุปกรณ์พยุงน้าหนักไว้ที่หินก้อนใดได้บ้าง

## ขอบเขตข้อมูล
$5$ $\leq$ $N$ $\leq$ $20,000$
$1 \leq W[i] \leq 100,000$
$1 \leq L[i] \leq 5,000,000$

## ไอเดียหลัก
เนื่องจากเราสามารถใช้อุปกรณ์พยุงน้ำหนักได้แค่ชิ้นเดียว เราจึงสามารถคิดแยก 2 กรณีได้ ก็คือ คิดวิธีการวางจากบนลงล่าง และจากล่างขึ้นบน

## วิธีทำ
เราจะใช้ Dynamic Programming ในการทำ โดยเราจะเก็บ array ไว้ 4 ตัว ได้แก่
- $dpu[]$ (ย่อจาก dp up) โดย $dpu[i]$ จะเก็บว่า ถ้าเราหยิบก้อนหินมา $i$ อัน จากด้านบน เราจะสามารถใช้น้ำหนักน้อยสุดเท่าไหร่ (ผลรวมค่า $W$ ที่มากที่สุดเท่าที่เป็นไปได้)
- $dpd[]$ (ย่อจาก dp down) โดย $dpd[i]$ จะเก็บว่า ถ้าเราหยิบก้อนหินมา $i$ อันจากด้านล่าง เราจะเหลือน้ำหนักที่รับได้มากสุดเท่าไหร่ (ค่า $L$ ที่เหลือได้มากที่สุดเท่าที่เป็นไปได้)
- $up[]$ โดย $up[i]$ จะเก็บว่า ถ้าหากว่าเราพิจารณาแค่ก้อนหินที่ $1$ ถึง $i$ เราจะสามารถหยิบมาได้มากที่สุดกี่ก้อน โดยจะใช้ $dpu[]$ ในการช่วยคำนวณในส่วนนี้
- $down[]$ โดย $down[i]$ จะเก็บว่า ถ้าหากว่าเราพิจารณาแค่ก้อนหินที่ $i$ ถึง $N$ เราจะสามารถหยิบมาได้มากที่สุดกี่ก้อน โดยจะใช้ $dpd[]$ ในการช่วยคำนวณในส่วนนี้
## การคำนวณ $up[]$
เราจะทำการ loop $i$ จาก $1$ ถึง $N$ โดยแต่ละรอบที่วน เราจะ loop $j$ จาก $i$ ถึง $1$ แล้ว เงื่อนไขการคำนวณของเราจะเป็นดังนี้:
- $dpu[j - 1] > l[i]$ 
	- แสดงว่า น้ำหนักที่น้อยที่สุดที่ต้องใช้ในการหยิบหินมา $j - 1$ ก้อนจากด้านบน มากกว่าน้ำหนักสูงสุดที่ก้อนหินก้อนที่ $i$ รับได้ เราก็ไม่ต้องทำอะไร (ทำอะไรไม่ได้)
- $dpu[j - 1] \leq l[i]$
	- แสดงว่า ก้อนหินก้อนที่ $i$ สามารถรับน้ำหนักของก้อนหินด้านบนจำนวน $j -  1$ ก้อนได้ ทำให้เราสามารถหยิบก้อนหินได้ $j$ ก้อน จาก $1$ ถึง $i$ เราก็จะทำการอัพเดตค่าของ $dpu[j]$ และ $up[i]$ ดังนี้
		- $up[i] = max(up[i], j):$ ก็คือ เราสามารถหยิบก้อนหิน $j$ ก้อนได้จากด้านบน เราก็จะให้ $up[i]$ เป็น ค่าที่มากกว่าระหว่าง ตัวมันเอง และ $j$
		- $dpu[j] =  min(dpu[j], dpu[j - 1] + w[i]):$ ก็คือ เนื่องจาก $dpu[j]$ จะเก็บผลรวมน้ำหนักที่น้อยที่สุดที่ใช้ในการหยิบก้อนหิน $j$ ก้อนจากด้านบน เราก็จะให้ $dpu[j]$ เป็นค่าที่น้อยกว่าระหว่าง ตัวมันเอง และ $dpu[j - 1] + w[i]$ (ซึ่งก็คือ น้ำหนักที่น้อยที่สุดที่ใช้ในการหยิบก้อนหิน $j - 1$ ก้อน บวกกับ น้ำหนักของก้อนหินก้อนปัจจุบัน)
## การคำนวณ $down[]$
เราจะทำการ loop $i$ จาก $N$ ถึง $1$ โดยแต่ละรอบที่วน เราจะ loop $j$ จาก $N - i + 1$ ถึง $1$ (loop ด้านในจะวนจำนวนก้อนหินที่เป็นไปได้ทั้งหมดถ้าเราพิจารณาก้อนหินก้อนที่ $i$ ถึง $N$) แล้ว เงื่อนไขการคำนวณของเราจะเป็นดังนี้:
- $dpd[j - 1] < w[i]$ 
	- แสดงว่า น้ำหนักที่รับได้มากสุดที่เหลือจากการหยิบหินมา $j - 1$ ก้อนจากด้านล่าง น้อยกว่าน้ำหนักของก้อนหินก้อนที่ $i$ เราก็ไม่ต้องทำอะไร (ทำอะไรไม่ได้)
- $dpd[j - 1] \geq w[i]$
	- แสดงว่า ก้อนหินก้อนที่ $i$ น้ำหนักน้อยกว่าหรือเท่ากับน้ำหนักที่รับได้มากสุดของก้อนหินด้านล่างจำนวน $j -  1$ ก้อนได้ ทำให้เราสามารถหยิบก้อนหินได้ $j$ ก้อน จาก $i$ ถึง $N$ เราก็จะทำการอัพเดตค่าของ $dpd[j]$ และ $down[i]$ ดังนี้
		- $down[i]  =  max(down[i], j):$ ก็คือ เราสามารถหยิบก้อนหิน $j$ ก้อนได้จากด้านล่าง เราก็จะให้ $down[i]$ เป็น ค่าที่มากกว่าระหว่าง ตัวมันเอง และ $j$
		- $dpd[j]  =  max(dpd[j],  min(l[i], dpd[j -  1]  - w[i])):$ ก็คือ เนื่องจาก $dpd[j]$ จะเก็บน้ำหนักที่รับได้มากสุดหลังจากที่หยิบก้อนหิน $j$ ก้อนจากด้านล่าง เราก็จะให้ $dpd[j]$ เป็นค่าที่มากกว่าระหว่าง ตัวมันเอง และ $min(l[i], dpd[j -  1]  - w[i])$ ซึ่งเหตุผลที่เราต้องหาค่าที่น้อยกว่า เป็นเพราะว่า ก้อนหินใหม่ที่เราหยิบมา (ก้อนที่ $i$) อาจจะสามารถรับน้ำหนักได้น้อยกว่าก้อนหินที่อยู่ด้านล่าง $(dpd[j - 1])$ ดังนั้น เราจึงต้องหาค่าที่น้อยกว่าระหว่างสองค่านั้น
## การหาคำตอบ 
ทำการ loop จาก $1$ ถึง $N$ แล้วหาค่าที่มากที่สุดของ $up[i] + down[i + 1]$ สำหรับทุกๆ $i$ (เนื่องจากเรามีอุปกรณ์พยุงน้ำหนัก ที่จะช่วยรับน้ำหนักด้านบนได้ทั้งหมด เราจึงทำแบบนี้ได้)
## การหาตำแหน่งที่จะวางอุปกรณ์พยุงน้ำหนัก
ทำการ loop จาก $1$ ถึง $N$ แล้วเช็กว่า $up[i] + down[i + 1] == mx$ หรือเปล่า ถ้าใช่ ให้ตอบค่า $i$ พร้อมกับ whitespace และทำแบบนี้สำหรับทุกๆ $i$
## Summary
- ใช้ Dynamic Programming ในการคำนวณจากบนลงล่างและล่างขึ้นบน โดยเมื่อคำนวณเสร็จแล้ว เราก็แค่เช็กถ้า $up[i] + down[i + 1] == ans$ ก็พิมพ์ $i$ ออกไป

## Solution Code: 
```cpp
#include <bits/stdc++.h> 

#define int long long 

using namespace std; 

const int inf = 1e18; 

int32_t main(){ 
	cin.tie(NULL)->sync_with_stdio(false); 
	int n; cin >> n; 
	vector <int> w(n + 2), l(n + 2); 
	for (int i = 1; i <= n; i++) cin >> w[i] >> l[i]; 
	vector <int> up(n + 2), down(n + 2), dpu(n + 2, inf), dpd(n + 2); dpu[0] = 0; 
	for (int i = 1; i <= n; i++) { 
		for (int j = i; j >= 1; j--) { 
			if (dpu[j - 1] <= l[i]) { 
				up[i] = max(up[i], j); 
				dpu[j] = min(dpu[j], dpu[j - 1] + w[i]); 
			} 
		} 
	} 
	dpd[0] = inf; 
	for (int i = n; i >= 1; i--) { 
		down[i] = down[i + 1];
		for (int j = n - i + 1; j >= 1; j--) { 
			if (dpd[j - 1] >= w[i]) { 
				down[i] = max(down[i], j);
				dpd[j] = max(dpd[j], min(l[i], dpd[j - 1] - w[i])); 
			} 
		} 
	} 
	int ans = 0; 
	for (int i = 1; i < n; i++) { 
		ans = max(ans, up[i] + down[i + 1]); 
	} 
	cout << ans << "\n"; 
	for (int i = 1; i < n; i++) { 
		if (up[i] + down[i + 1] == ans) cout << i << " "; 
	} 
}
```
## Total Time Complexity: $O(n^2)$

หากมีข้อสงสัย comment ไว้ใต้ post ได้เลยนะครับ 🙇‍♂️🙇‍♂️
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwMDQwNzU5Nl19
-->
